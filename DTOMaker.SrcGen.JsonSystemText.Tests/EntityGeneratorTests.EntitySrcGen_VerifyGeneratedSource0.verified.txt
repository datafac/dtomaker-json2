// <auto-generated>
// This file was generated by DTOMaker.JsonSystemText.
// NuGet: https://www.nuget.org/packages/DTOMaker.JsonSystemText
// Warning: Changes made to this file will be lost if re-generated.
// </auto-generated>
#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required
#nullable enable
using DataFac.Memory;
using DTOMaker.Runtime;
using DTOMaker.Runtime.JsonSystemText;
using System;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text.Json.Serialization;
using MyOrg.Models;

namespace MyOrg.Models
{
    [JsonPolymorphic]
    [JsonDerivedType(typeof(MyOrg.Model2.MyDTO), 3)]
    [JsonDerivedType(typeof(MyOrg.Model3.MyDTO), 4)]
    [JsonDerivedType(typeof(MyOrg.Models.Derived), 2)]
    [JsonDerivedType(typeof(MyOrg.Models.MyDTO), 1)]
    public class EntityBase : IEntityBase, IEquatable<EntityBase>
    {
        protected virtual int OnGetEntityId() => 0;
        public int GetEntityId() => OnGetEntityId();

        private static EntityBase CreateEmpty()
        {
            var empty = new EntityBase();
            empty.Freeze();
            return empty;
        }
        private static readonly EntityBase _empty = CreateEmpty();
        public static EntityBase Empty => _empty;

        public static EntityBase CreateFrom(EntityBase source)
        {
            if (source.IsFrozen) return source;
            return source switch
            {
                MyOrg.Models.Derived source2 => new MyOrg.Models.Derived(source2),
                MyOrg.Model2.MyDTO source2 => new MyOrg.Model2.MyDTO(source2),
                MyOrg.Model3.MyDTO source2 => new MyOrg.Model3.MyDTO(source2),
                MyOrg.Models.MyDTO source2 => new MyOrg.Models.MyDTO(source2),
                _ => new EntityBase(source)
            };
        }

        public new static EntityBase CreateFrom(IEntityBase source)
        {
            if (source is EntityBase concrete && concrete.IsFrozen) return concrete;
            return source switch
            {
                MyOrg.Models.IDerived source2 => new MyOrg.Models.Derived(source2),
                MyOrg.Model2.IMyDTO source2 => new MyOrg.Model2.MyDTO(source2),
                MyOrg.Model3.IMyDTO source2 => new MyOrg.Model3.MyDTO(source2),
                MyOrg.Models.IMyDTO source2 => new MyOrg.Models.MyDTO(source2),
                _ => new EntityBase(source)
            };
        }

        public new static EntityBase CreateNewFromId(int entityId)
        {
            if (entityId == 0) return new EntityBase();
            return entityId switch
            {
                1 => new MyOrg.Models.MyDTO(),
                2 => new MyOrg.Models.Derived(),
                3 => new MyOrg.Model2.MyDTO(),
                4 => new MyOrg.Model3.MyDTO(),
                _ => throw new InvalidOperationException($"EntityId '{entityId}' is not valid.")
            };
        }

        public EntityBase() { }
        public EntityBase(IEntityBase notUsed) { }
        public EntityBase(EntityBase notUsed) { }

        private volatile bool _frozen;
        [JsonIgnore] public bool IsFrozen => _frozen;
        protected virtual void OnFreeze() { }
        public void Freeze()
        {
            if (_frozen) return;
            OnFreeze();
            _frozen = true;
        }
        protected virtual IEntityBase OnPartCopy() => new EntityBase(this);
        public IEntityBase PartCopy() => OnPartCopy();

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void ThrowIsFrozenException(string? methodName) => throw new InvalidOperationException($"Cannot set {methodName} when frozen.");

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected T IfNotFrozen<T>(T value, [CallerMemberName] string? methodName = null)
        {
            if (_frozen) ThrowIsFrozenException(methodName);
            return value;
        }

        public bool Equals(EntityBase? other) => true;
        public override bool Equals(object? obj) => obj is EntityBase;
        public override int GetHashCode() => HashCode.Combine<Type>(typeof(EntityBase));

        protected static bool BinaryValuesAreEqual(byte[]? left, byte[]? right)
        {
            if (left is null) return (right is null);
            if (right is null) return false;
            return left.AsSpan().SequenceEqual(right.AsSpan());
        }

    }
}
